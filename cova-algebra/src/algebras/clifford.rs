//! Implementation of Clifford algebras, also known as geometric algebras.
//!
//! A Clifford algebra is a unital associative algebra that generalizes the real numbers, complex
//! numbers, quaternions, and several other hypercomplex number systems. The key feature of a
//! Clifford algebra is that it is generated by a vector space equipped with a quadratic form.
//!
//! # Key Concepts
//!
//! - **Quadratic Form**: A function Q: V → F that satisfies Q(av) = a²Q(v) for all a ∈ F and v ∈ V.
//!   In this implementation, we assume the quadratic form is diagonal, represented by a vector of
//!   coefficients.
//!
//! - **Basis Blades**: The fundamental building blocks of a Clifford algebra. In an n-dimensional
//!   space, there are 2ⁿ basis blades, formed by taking the exterior product of basis vectors.
//!
//! - **Grade**: The number of basis vectors in a blade. A scalar has grade 0, a vector has grade 1,
//!   a bivector has grade 2, and so on.
//!
//! # Implementation Details
//!
//! The implementation uses a bit-based representation for basis blades:
//!
//! - Each basis blade is represented by a bit position in a 2ⁿ-dimensional vector
//! - The grade of a blade is determined by the number of set bits
//! - Multiplication is implemented using the geometric product, which combines the exterior product
//!   and the inner product defined by the quadratic form
//!
//! # Examples
//!
//! ```
//! #![feature(generic_const_exprs)]
//! use cova_algebra::{
//!   algebras::clifford::{CliffordAlgebra, QuadraticForm},
//!   tensors::SVector,
//! };
//!
//! // Create a 3D Clifford algebra with signature (+, +, -)
//! let quadratic_form = QuadraticForm::new(SVector::<f64, 3>::from_row_slice(&[1.0, 1.0, -1.0]));
//! let algebra = CliffordAlgebra::new(quadratic_form);
//!
//! // Create basis vectors
//! let e0 = algebra.blade([0]);
//! let e1 = algebra.blade([1]);
//! let e2 = algebra.blade([2]);
//!
//! // Example: e1 * e01 = -e0 (using the quadratic form)
//! let e01 = algebra.blade([0, 1]);
//! assert_eq!(format!("{}", e1 * e01), "-1e₀");
//!
//! // Example: e2 * e2 = -1 (using the quadratic form)
//! assert_eq!(format!("{}", e2.clone() * e2), "-1");
//! ```
//!
//! # Geometric Interpretation
//!
//! The geometric product of two vectors a and b can be decomposed as:
//!
//! a * b = a·b + a∧b
//!
//! where:
//! - a·b is the inner product (symmetric part)
//! - a∧b is the exterior product (antisymmetric part)
//!
//! This decomposition is fundamental to geometric algebra and allows for a unified treatment of
//! various geometric operations.
//!
//! # Common Use Cases
//!
//! - **3D Euclidean Space**: Used for 3D rotations and transformations
//! - **Spacetime Physics**: Used in special relativity with signature (+, -, -, -)
//! - **Computer Graphics**: Used for efficient representation of transformations
//! - **Robotics**: Used for representing and manipulating rigid body motions
//!
//! # References
//!
//! - [Geometric Algebra for Computer Science](https://www.geometricalgebra.net/)
//! - [Clifford Algebra](https://en.wikipedia.org/wiki/Clifford_algebra)
//! - [Geometric Algebra](https://en.wikipedia.org/wiki/Geometric_algebra)

use std::fmt::{Debug, Display, Formatter};

use num_traits::One;

use super::*;
use crate::{
  algebras::Algebra,
  groups::{AbelianGroup, Group},
  modules::{LeftModule, RightModule, TwoSidedModule},
  rings::Field,
  tensors::SVector,
};

/// A quadratic form on a vector space, represented in diagonal form.
///
/// A quadratic form Q is a function that satisfies Q(av) = a²Q(v) for all scalars a and vectors v.
/// In this implementation, we assume the quadratic form is diagonal, meaning it can be represented
/// by a vector of coefficients where Q(v) = Σᵢ cᵢvᵢ².
///
/// # Examples
///
/// ```
/// use cova_algebra::{algebras::clifford::QuadraticForm, tensors::SVector};
///
/// // Create a quadratic form with coefficients [1, 1, -1]
/// let q = QuadraticForm::new(SVector::<f64, 3>::from_row_slice(&[1.0, 1.0, -1.0]));
/// ```
#[derive(Clone, Debug, PartialEq)]
pub struct QuadraticForm<F: Field, const N: usize> {
  coefficients: SVector<F, N>,
}

impl<F: Field + Copy, const N: usize> QuadraticForm<F, N> {
  /// Creates a new quadratic form with the given coefficients.
  ///
  /// # Arguments
  ///
  /// * `coefficients` - A vector of coefficients for the quadratic form
  ///
  /// # Examples
  ///
  /// ```
  /// use cova_algebra::{algebras::clifford::QuadraticForm, tensors::SVector};
  ///
  /// let q = QuadraticForm::new(SVector::<f64, 3>::from_row_slice(&[1.0, 1.0, -1.0]));
  /// ```
  pub const fn new(coefficients: SVector<F, N>) -> Self { Self { coefficients } }

  /// Evaluates the quadratic form at a given vector.
  ///
  /// # Arguments
  ///
  /// * `v` - The vector at which to evaluate the quadratic form
  ///
  /// # Returns
  ///
  /// The value of Q(v) = Σᵢ cᵢvᵢ²
  ///
  /// # Examples
  ///
  /// ```
  /// use cova_algebra::{algebras::clifford::QuadraticForm, tensors::SVector};
  ///
  /// let q = QuadraticForm::new(SVector::<f64, 3>::from_row_slice(&[1.0, 1.0, -1.0]));
  /// let v = SVector::<f64, 3>::from_row_slice(&[1.0, 2.0, 3.0]);
  /// assert_eq!(q.evaluate(&v), 1.0 + 4.0 - 9.0); // 1*1² + 1*2² + (-1)*3²
  /// ```
  pub fn evaluate(&self, v: &SVector<F, N>) -> F {
    let mut result = F::zero();
    for i in 0..N {
      result += self.coefficients[i] * v[i] * v[i];
    }
    result
  }
}

/// A Clifford algebra over a vector space with a given quadratic form.
///
/// A Clifford algebra is a unital associative algebra that generalizes the real numbers,
/// complex numbers, and quaternions. It is generated by a vector space equipped with a
/// quadratic form.
///
/// # Type Parameters
///
/// * `F` - The field over which the algebra is defined
/// * `N` - The dimension of the underlying vector space
///
/// # Examples
///
/// ```
/// #![feature(generic_const_exprs)]
/// use cova_algebra::{
///   algebras::clifford::{CliffordAlgebra, QuadraticForm},
///   tensors::SVector,
/// };
///
/// let quadratic_form = QuadraticForm::new(SVector::<f64, 3>::from_row_slice(&[1.0, 1.0, -1.0]));
/// let algebra = CliffordAlgebra::new(quadratic_form);
/// ```
pub struct CliffordAlgebra<F: Field, const N: usize> {
  quadratic_form: QuadraticForm<F, N>,
}

impl<F: Field + Copy, const N: usize> CliffordAlgebra<F, N>
where [(); 1 << N]:
{
  /// Creates a new Clifford algebra with the given quadratic form.
  ///
  /// # Arguments
  ///
  /// * `quadratic_form` - The quadratic form defining the algebra
  ///
  /// # Examples
  ///
  /// ```
  /// #![feature(generic_const_exprs)]
  /// use cova_algebra::{
  ///   algebras::clifford::{CliffordAlgebra, QuadraticForm},
  ///   tensors::SVector,
  /// };
  ///
  /// let quadratic_form = QuadraticForm::new(SVector::<f64, 3>::from_row_slice(&[1.0, 1.0, -1.0]));
  /// let algebra = CliffordAlgebra::new(quadratic_form);
  /// ```
  pub const fn new(quadratic_form: QuadraticForm<F, N>) -> Self { Self { quadratic_form } }

  /// Creates a new element in the algebra from a vector of coefficients.
  ///
  /// # Arguments
  ///
  /// * `value` - A vector of coefficients for each basis blade
  ///
  /// # Examples
  ///
  /// ```
  /// #![feature(generic_const_exprs)]
  /// use cova_algebra::{
  ///   algebras::clifford::{CliffordAlgebra, QuadraticForm},
  ///   tensors::SVector,
  /// };
  ///
  /// let algebra =
  ///   CliffordAlgebra::new(QuadraticForm::new(SVector::<f64, 3>::from_row_slice(&[1.0, 1.0, -1.0])));
  /// let element =
  ///   algebra.element(SVector::<f64, 8>::from_row_slice(&[1.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0]));
  /// ```
  pub fn element(&self, value: SVector<F, { 1 << N }>) -> CliffordAlgebraElement<F, N> {
    CliffordAlgebraElement { value, quadratic_form: Some(self.quadratic_form.clone()) }
  }

  /// Creates a basis blade with the given indices.
  ///
  /// A basis blade is a product of basis vectors, represented by their indices.
  /// The indices must be sorted and unique.
  ///
  /// # Arguments
  ///
  /// * `indices` - The indices of the basis vectors that form the blade
  ///
  /// # Panics
  ///
  /// Panics if the indices are not sorted or if any index is out of range.
  ///
  /// # Examples
  ///
  /// ```
  /// #![feature(generic_const_exprs)]
  /// use cova_algebra::{
  ///   algebras::clifford::{CliffordAlgebra, QuadraticForm},
  ///   tensors::SVector,
  /// };
  ///
  /// let algebra =
  ///   CliffordAlgebra::new(QuadraticForm::new(SVector::<f64, 3>::from_row_slice(&[1.0, 1.0, -1.0])));
  /// let e1 = algebra.blade([1]);
  /// let e01 = algebra.blade([0, 1]);
  /// ```
  pub fn blade<const I: usize>(&self, indices: [usize; I]) -> CliffordAlgebraElement<F, N> {
    // Validate indices are in range and sorted
    for i in 1..I {
      assert!(
        indices[i - 1] < indices[i] && indices[i] < N,
        "Indices must be sorted and in
    range"
      );
    }

    // Convert indices to bit position using our helper function
    let bit_position = Self::blade_indices_to_bit(&indices);

    let mut value = SVector::<F, { 1 << N }>::zeros();
    value[bit_position] = <F as One>::one();

    CliffordAlgebraElement { value, quadratic_form: Some(self.quadratic_form.clone()) }
  }

  /// Maps a set of basis blade indices back to a bit position.
  /// This is the inverse of [`bit_to_blade_indices`].
  fn blade_indices_to_bit(indices: &[usize]) -> usize {
    let grade = indices.len();
    let mut bit_position = 0;

    // Add up all the positions from lower grades
    for g in 0..grade {
      bit_position += binomial(N, g);
    }

    // Now add the position within this grade
    let mut remaining_bits = 0;
    for (i, &idx) in indices.iter().enumerate() {
      // For each index, add the number of combinations that come before it
      for j in if i == 0 { 0 } else { indices[i - 1] + 1 }..idx {
        remaining_bits += binomial(N - j - 1, grade - i - 1);
      }
    }

    bit_position + remaining_bits
  }
}

/// Computes the binomial coefficient C(n, k)
fn binomial(n: usize, k: usize) -> usize {
  if k > n {
    return 0;
  }
  if k == 0 || k == n {
    return 1;
  }
  let k = std::cmp::min(k, n - k);
  let mut result = 1;
  for i in 1..=k {
    result = result * (n - k + i) / i;
  }
  result
}

/// An element of a Clifford algebra.
///
/// An element is represented as a linear combination of basis blades, where each
/// basis blade is a product of basis vectors.
///
/// # Type Parameters
///
/// * `'a` - The lifetime of the reference to the quadratic form
/// * `F` - The field over which the algebra is defined
/// * `N` - The dimension of the underlying vector space
///
/// # Examples
///
/// ```
/// #![feature(generic_const_exprs)]
/// use cova_algebra::{
///   algebras::clifford::{CliffordAlgebra, QuadraticForm},
///   tensors::SVector,
/// };
///
/// let algebra =
///   CliffordAlgebra::new(QuadraticForm::new(SVector::<f64, 3>::from_row_slice(&[1.0, 1.0, -1.0])));
/// let e1 = algebra.blade([1]);
/// let e2 = algebra.blade([2]);
/// let sum = e1 + e2;
/// ```
#[derive(Clone, Debug, PartialEq)]
pub struct CliffordAlgebraElement<F: Field, const N: usize>
where [(); 1 << N]: {
  value:          SVector<F, { 1 << N }>,
  quadratic_form: Option<QuadraticForm<F, N>>, // Owned quadratic form for element
}

// TODO: All of these impls should check the same bilinear space. This should probably be a compile
// time thing.

impl<F: Field, const N: usize> Add for CliffordAlgebraElement<F, N>
where [(); 1 << N]:
{
  type Output = Self;

  fn add(self, other: Self) -> Self::Output {
    assert_eq!(self.quadratic_form, other.quadratic_form);
    Self { value: self.value + other.value, quadratic_form: self.quadratic_form.clone() }
  }
}

impl<F: Field, const N: usize> AddAssign for CliffordAlgebraElement<F, N>
where [(); 1 << N]:
{
  fn add_assign(&mut self, rhs: Self) {
    assert_eq!(self.quadratic_form, rhs.quadratic_form);
    self.value += rhs.value;
  }
}

impl<F: Field, const N: usize> Neg for CliffordAlgebraElement<F, N>
where [(); 1 << N]:
{
  type Output = Self;

  fn neg(self) -> Self::Output {
    Self { value: -self.value, quadratic_form: self.quadratic_form.clone() }
  }
}

impl<F: Field, const N: usize> Sub for CliffordAlgebraElement<F, N>
where [(); 1 << N]:
{
  type Output = Self;

  fn sub(self, other: Self) -> Self::Output { self + -other }
}

impl<F: Field, const N: usize> SubAssign for CliffordAlgebraElement<F, N>
where [(); 1 << N]:
{
  fn sub_assign(&mut self, rhs: Self) {
    assert_eq!(self.quadratic_form, rhs.quadratic_form);
    self.value -= rhs.value;
  }
}

impl<F: Field, const N: usize> Mul for CliffordAlgebraElement<F, N>
where [(); 1 << N]:
{
  type Output = Self;

  fn mul(self, other: Self) -> Self::Output {
    assert_eq!(self.quadratic_form, other.quadratic_form);
    let quadratic_form =
      self.quadratic_form.as_ref().expect("Both elements must have a quadratic form");

    let mut result = SVector::<F, { 1 << N }>::zeros();

    // For each non-zero component in the first element
    for i in 0..(1 << N) {
      if self.value[i].is_zero() {
        continue;
      }

      // For each non-zero component in the second element
      for j in 0..(1 << N) {
        if other.value[j].is_zero() {
          continue;
        }

        // Get the indices for both basis blades
        let left_indices = bit_to_blade_indices::<N>(i);
        let right_indices = bit_to_blade_indices::<N>(j);

        // Calculate the sign and product indices
        let (sign, product_indices) = multiply_blades::<N>(&left_indices, &right_indices);

        // Calculate the coefficient
        let mut coefficient = self.value[i] * other.value[j];

        // Apply sign
        coefficient = match sign {
          Sign::Positive => coefficient,
          Sign::Negative => -coefficient,
        };

        // Apply quadratic form for any repeated indices
        let mut repeated_indices = Vec::new();
        let mut i = 0;
        let mut j = 0;
        while i < left_indices.len() && j < right_indices.len() {
          match left_indices[i].cmp(&right_indices[j]) {
            std::cmp::Ordering::Equal => {
              repeated_indices.push(left_indices[i]);
              i += 1;
              j += 1;
            },
            std::cmp::Ordering::Less => {
              i += 1;
            },
            std::cmp::Ordering::Greater => {
              j += 1;
            },
          }
        }

        // Multiply by quadratic form coefficients for each repeated index
        for &idx in &repeated_indices {
          coefficient *= quadratic_form.coefficients[idx];
        }

        // Add to the result
        let product_bit = blade_indices_to_bit::<N>(&product_indices);
        result[product_bit] += coefficient;
      }
    }

    Self { value: result, quadratic_form: self.quadratic_form.clone() }
  }
}

impl<F: Field, const N: usize> MulAssign for CliffordAlgebraElement<F, N>
where [(); 1 << N]:
{
  fn mul_assign(&mut self, rhs: Self) {
    let result = self.clone() * rhs;
    *self = result;
  }
}

impl<F: Field, const N: usize> Mul<F> for CliffordAlgebraElement<F, N>
where [(); 1 << N]:
{
  type Output = Self;

  fn mul(self, rhs: F) -> Self::Output {
    Self { value: self.value * rhs, quadratic_form: self.quadratic_form.clone() }
  }
}

impl<F: Field, const N: usize> Multiplicative for CliffordAlgebraElement<F, N> where [(); 1 << N]: {}

// TODO: This is weird... i'll use option to note the zero element.
impl<F: Field, const N: usize> Zero for CliffordAlgebraElement<F, N>
where [(); 1 << N]:
{
  fn zero() -> Self { Self { value: SVector::<F, { 1 << N }>::zeros(), quadratic_form: None } }

  fn is_zero(&self) -> bool { self.value.iter().all(|x| x.is_zero()) }
}

impl<F: Field, const N: usize> Additive for CliffordAlgebraElement<F, N> where [(); 1 << N]: {}
impl<F: Field, const N: usize> Group for CliffordAlgebraElement<F, N>
where [(); 1 << N]:
{
  fn identity() -> Self {
    CliffordAlgebraElement {
      value:          SVector::<F, { 1 << N }>::zeros(),
      quadratic_form: None,
    }
  }

  fn inverse(&self) -> Self {
    Self { value: -self.value, quadratic_form: self.quadratic_form.clone() }
  }
}
impl<F: Field, const N: usize> AbelianGroup for CliffordAlgebraElement<F, N> where [(); 1 << N]: {}
impl<F: Field + Mul<Self>, const N: usize> LeftModule for CliffordAlgebraElement<F, N>
where [(); 1 << N]:
{
  type Ring = F;
}
impl<F: Field + Mul<Self>, const N: usize> RightModule for CliffordAlgebraElement<F, N>
where [(); 1 << N]:
{
  type Ring = F;
}
impl<F: Field + Mul<Self>, const N: usize> TwoSidedModule for CliffordAlgebraElement<F, N>
where [(); 1 << N]:
{
  type Ring = F;
}
impl<F: Field + Mul<Self>, const N: usize> VectorSpace for CliffordAlgebraElement<F, N> where [(); 1 << N]: {}
impl<F: Field + Mul<Self>, const N: usize> Algebra for CliffordAlgebraElement<F, N> where [(); 1 << N]: {}

impl<F: Field + Display, const N: usize> Display for CliffordAlgebraElement<F, N>
where [(); 1 << N]:
{
  fn fmt(&self, f: &mut Formatter<'_>) -> std::fmt::Result {
    let mut first = true;

    // Helper function to write basis element
    let write_basis = |f: &mut Formatter<'_>, indices: &[usize]| -> std::fmt::Result {
      if indices.is_empty() {
        return Ok(());
      }

      write!(f, "e")?;
      for (i, &index) in indices.iter().enumerate() {
        // Convert number to Unicode subscript by converting each digit
        let num = index;
        for digit in num.to_string().chars() {
          let subscript = match digit {
            '0' => "₀",
            '1' => "₁",
            '2' => "₂",
            '3' => "₃",
            '4' => "₄",
            '5' => "₅",
            '6' => "₆",
            '7' => "₇",
            '8' => "₈",
            '9' => "₉",
            _ => panic!("Invalid digit"),
          };
          write!(f, "{subscript}")?;
        }

        if i < indices.len() - 1 {
          write!(f, "‚")?;
        }
      }
      Ok(())
    };

    // Print each grade in order
    for grade in 0..=N {
      // Generate all possible combinations of indices for this grade
      let mut indices = Vec::with_capacity(grade);
      let mut combinations = Vec::new();
      generate_combinations(0, N, grade, &mut indices, &mut combinations);

      // Sort combinations by their bit position
      combinations.sort_by_key(|indices| CliffordAlgebra::<F, N>::blade_indices_to_bit(indices));

      // Print each combination in order
      for indices in combinations {
        let bit_position = CliffordAlgebra::<F, N>::blade_indices_to_bit(&indices);
        if !self.value[bit_position].is_zero() {
          if !first {
            write!(f, " + ")?;
          }
          write!(f, "{}", self.value[bit_position])?;
          if grade > 0 {
            write_basis(f, &indices)?;
          }
          first = false;
        }
      }
    }

    if first {
      write!(f, "0")?;
    }
    Ok(())
  }
}

/// Helper function to generate all combinations of indices for a given grade
fn generate_combinations(
  start: usize,
  n: usize,
  k: usize,
  current: &mut Vec<usize>,
  result: &mut Vec<Vec<usize>>,
) {
  if k == 0 {
    result.push(current.clone());
    return;
  }

  for i in start..n {
    current.push(i);
    generate_combinations(i + 1, n, k - 1, current, result);
    current.pop();
  }
}

/// A macro that implements scalar multiplication for Clifford algebra elements.
///
/// This macro generates implementations of the `Mul` trait for scalar types (like `f32` and `f64`)
/// to allow multiplication with `CliffordAlgebraElement`s. It enables syntax like `2.0 * element`
/// in addition to `element * 2.0`.
///
/// # Examples
///
/// ```
/// #![feature(generic_const_exprs)]
/// use cova_algebra::{
///   algebras::clifford::{CliffordAlgebra, QuadraticForm},
///   tensors::SVector,
/// };
///
/// let algebra =
///   CliffordAlgebra::new(QuadraticForm::new(SVector::<f64, 3>::from_row_slice(&[1.0, 1.0, -1.0])));
/// let e1 = algebra.blade([1]);
///
/// // Both of these are valid thanks to this macro
/// let doubled1 = 2.0 * e1.clone();
/// let doubled2 = e1 * 2.0;
/// ```
/// This allows scalar multiplication to be commutative, delegating to the existing
/// right-multiplication implementation.
#[macro_export]
macro_rules! impl_mul_scalar_clifford {
  ($($t:ty)*) => ($(
    impl<const N: usize> Mul<CliffordAlgebraElement<$t, N>> for $t
    where [(); 1 << N]:
    {
      type Output = CliffordAlgebraElement<$t, N>;

      fn mul(self, rhs: CliffordAlgebraElement<$t, N>) -> Self::Output { rhs * self }
    }
  )*)
}

impl_mul_scalar_clifford!(f32);
impl_mul_scalar_clifford!(f64);

/// Represents the sign of a term in the algebra.
///
/// Used internally to track sign changes during multiplication.
#[derive(Debug)]
pub enum Sign {
  /// Positive sign
  Positive,
  /// Negative sign
  Negative,
}

/// Helper function to multiply two basis blades
fn multiply_blades<const N: usize>(left: &[usize], right: &[usize]) -> (Sign, Vec<usize>) {
  let mut result_indices = Vec::new();
  let mut sign = Sign::Positive;

  // Handle the case where either blade is empty (scalar)
  if left.is_empty() {
    return (Sign::Positive, right.to_vec());
  }
  if right.is_empty() {
    return (Sign::Positive, left.to_vec());
  }

  // Merge the indices while keeping track of sign changes
  let mut i = 0;
  let mut j = 0;

  while i < left.len() && j < right.len() {
    match left[i].cmp(&right[j]) {
      std::cmp::Ordering::Equal => {
        // Same index: apply quadratic form
        i += 1;
        j += 1;
      },
      std::cmp::Ordering::Less => {
        // Left index comes first: no sign change
        result_indices.push(left[i]);
        i += 1;
      },
      std::cmp::Ordering::Greater => {
        // Right index comes first: count swaps for sign
        result_indices.push(right[j]);
        if (left.len() - i) % 2 == 1 {
          sign = match sign {
            Sign::Positive => Sign::Negative,
            Sign::Negative => Sign::Positive,
          };
        }
        j += 1;
      },
    }
  }

  // Add remaining indices
  result_indices.extend_from_slice(&left[i..]);
  result_indices.extend_from_slice(&right[j..]);

  (sign, result_indices)
}

/// Maps a bit position to the corresponding basis blade indices.
fn bit_to_blade_indices<const N: usize>(bits: usize) -> Vec<usize> {
  let mut remaining_bits = bits;
  let mut grade = 0;

  // Find which grade this element belongs to
  while grade <= N {
    let grade_size = binomial(N, grade);
    if remaining_bits < grade_size {
      break;
    }
    remaining_bits -= grade_size;
    grade += 1;
  }

  // Now we know the grade, we need to find which combination of indices
  // corresponds to the remaining_bits position within that grade
  let mut indices = Vec::with_capacity(grade);
  let mut current = 0;

  for _ in 0..grade {
    // Find the next index to include
    while current < N {
      let remaining_combinations = binomial(N - current - 1, grade - indices.len() - 1);
      if remaining_bits < remaining_combinations {
        indices.push(current);
        current += 1;
        break;
      }
      remaining_bits -= remaining_combinations;
      current += 1;
    }
  }

  indices
}

/// Maps a set of basis blade indices back to a bit position.
fn blade_indices_to_bit<const N: usize>(indices: &[usize]) -> usize {
  let grade = indices.len();
  let mut bit_position = 0;

  // Add up all the positions from lower grades
  for g in 0..grade {
    bit_position += binomial(N, g);
  }

  // Now add the position within this grade
  let mut remaining_bits = 0;
  for (i, &idx) in indices.iter().enumerate() {
    for j in if i == 0 { 0 } else { indices[i - 1] + 1 }..idx {
      remaining_bits += binomial(N - j - 1, grade - i - 1);
    }
  }

  bit_position + remaining_bits
}

#[cfg(test)]
mod tests {
  use super::*;

  fn clifford_algebra_non_euclidean() -> CliffordAlgebra<f64, 3> {
    let quadratic_form = QuadraticForm::new(SVector::<f64, 3>::from_row_slice(&[1.0, 1.0, -1.0]));
    CliffordAlgebra::new(quadratic_form)
  }

  fn clifford_algebra_euclidean() -> CliffordAlgebra<f64, 3> {
    let quadratic_form = QuadraticForm::new(SVector::<f64, 3>::from_row_slice(&[1.0, 1.0, 1.0]));
    CliffordAlgebra::new(quadratic_form)
  }

  #[test]
  fn test_display_order() {
    let algebra = clifford_algebra_non_euclidean();
    let one =
      algebra.element(SVector::<f64, 8>::from_row_slice(&[1.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0]));
    let e0 =
      algebra.element(SVector::<f64, 8>::from_row_slice(&[0.0, 1.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0]));
    let e1 =
      algebra.element(SVector::<f64, 8>::from_row_slice(&[0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 0.0, 0.0]));
    let e2 =
      algebra.element(SVector::<f64, 8>::from_row_slice(&[0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 0.0]));
    let e01 =
      algebra.element(SVector::<f64, 8>::from_row_slice(&[0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0]));
    let e02 =
      algebra.element(SVector::<f64, 8>::from_row_slice(&[0.0, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0]));
    let e12 =
      algebra.element(SVector::<f64, 8>::from_row_slice(&[0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0]));
    let e012 =
      algebra.element(SVector::<f64, 8>::from_row_slice(&[0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 1.0]));

    let sum = one + 2.0 * e0 + 3.0 * e1 + 4.0 * e2 + 5.0 * e01 + 6.0 * e02 + 7.0 * e12 + 8.0 * e012;
    assert_eq!(format!("{sum}"), "1 + 2e₀ + 3e₁ + 4e₂ + 5e₀‚₁ + 6e₀‚₂ + 7e₁‚₂ + 8e₀‚₁‚₂");
  }

  #[test]
  fn test_blade_indices_to_bit() {
    // Test scalar (empty indices)
    assert_eq!(CliffordAlgebra::<f64, 3>::blade_indices_to_bit(&[]), 0);

    // Test vectors
    assert_eq!(CliffordAlgebra::<f64, 3>::blade_indices_to_bit(&[0]), 1);
    assert_eq!(CliffordAlgebra::<f64, 3>::blade_indices_to_bit(&[1]), 2);
    assert_eq!(CliffordAlgebra::<f64, 3>::blade_indices_to_bit(&[2]), 3);

    // Test bivectors
    assert_eq!(CliffordAlgebra::<f64, 3>::blade_indices_to_bit(&[0, 1]), 4);
    assert_eq!(CliffordAlgebra::<f64, 3>::blade_indices_to_bit(&[0, 2]), 5);
    assert_eq!(CliffordAlgebra::<f64, 3>::blade_indices_to_bit(&[1, 2]), 6);

    // Test trivector
    assert_eq!(CliffordAlgebra::<f64, 3>::blade_indices_to_bit(&[0, 1, 2]), 7);
  }

  #[test]
  fn test_blade() {
    let algebra = clifford_algebra_non_euclidean();
    let e1 = algebra.blade([1]);
    assert_eq!(format!("{e1}"), "1e₁");
  }

  #[test]
  fn test_add() {
    let algebra = clifford_algebra_non_euclidean();
    let e1 = algebra.blade([1]);
    let e2 = algebra.blade([2]);
    let sum = e1 + e2;
    assert_eq!(format!("{sum}"), "1e₁ + 1e₂");
  }

  #[test]
  fn test_mul_basic() {
    let algebra = clifford_algebra_non_euclidean();
    let e1 = algebra.blade([1]);
    let e2 = algebra.blade([2]);
    let product = e1 * e2;
    assert_eq!(format!("{product}"), "1e₁‚₂");
  }

  #[test]
  fn test_mul_with_quadratic_form() {
    let algebra = clifford_algebra_non_euclidean();
    let e1 = algebra.blade([1]);
    let e01 = algebra.blade([0, 1]);
    let product = e1 * e01;
    assert_eq!(format!("{product}"), "-1e₀");
  }

  #[test]
  fn test_mul_euclidean() {
    let algebra = clifford_algebra_euclidean();
    let e1 = algebra.blade([1]);
    let e01 = algebra.blade([0, 1]);
    let product = e1 * e01;
    assert_eq!(format!("{product}"), "-1e₀");
  }

  #[test]
  fn test_mul_anti_commutativity() {
    let algebra = clifford_algebra_non_euclidean();
    let e0 = algebra.blade([0]);
    let e1 = algebra.blade([1]);
    let e2 = algebra.blade([2]);

    // Test anti-commutativity of basis vectors (clone to avoid move)
    assert_eq!(format!("{}", e0.clone() * e1.clone()), "1e₀‚₁");
    assert_eq!(format!("{}", e1.clone() * e0.clone()), "-1e₀‚₁");
    assert_eq!(format!("{}", e1.clone() * e2.clone()), "1e₁‚₂");
    assert_eq!(format!("{}", e2.clone() * e1), "-1e₁‚₂");
  }

  #[test]
  fn test_mul_scalar() {
    let algebra = clifford_algebra_non_euclidean();
    let one =
      algebra.element(SVector::<f64, 8>::from_row_slice(&[1.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0]));
    let e1 = algebra.blade([1]);
    let e2 = algebra.blade([2]);

    // Test scalar multiplication (clone to avoid move)
    assert_eq!(format!("{}", one.clone() * e1.clone()), "1e₁");
    assert_eq!(format!("{}", e1 * one.clone()), "1e₁");
    assert_eq!(format!("{}", one.clone() * e2.clone()), "1e₂");
    assert_eq!(format!("{}", e2 * one), "1e₂");
  }

  #[test]
  fn test_mul_quadratic_form_application() {
    let algebra = clifford_algebra_non_euclidean();
    let e0 = algebra.blade([0]);
    let e1 = algebra.blade([1]);
    let e2 = algebra.blade([2]);

    // Test quadratic form application
    assert_eq!(format!("{}", e0.clone() * e0), "1"); // Q(e0) = 1
    assert_eq!(format!("{}", e1.clone() * e1), "1"); // Q(e1) = 1
    assert_eq!(format!("{}", e2.clone() * e2), "-1"); // Q(e2) = -1
  }

  #[test]
  fn test_mul_higher_grade() {
    let algebra = clifford_algebra_non_euclidean();
    let e01 = algebra.blade([0, 1]);
    let e12 = algebra.blade([1, 2]);
    let e02 = algebra.blade([0, 2]);

    // Test multiplication of bivectors
    assert_eq!(format!("{}", e01.clone() * e12.clone()), "1e₀‚₂"); // e01 * e12 = e0 * e1 * e1 * e2 = e0 * Q(e1) * e2 = e0 * 1 * e2 = e0 * e2 = e02

    assert_eq!(format!("{}", e12.clone() * e01), "1e₀‚₂");
    assert_eq!(format!("{}", e02.clone() * e12), "1e₀‚₁"); // e02 * e12 = e0 * e2 * e1 * e2 = -e0 *
                                                           // e1 * e2
                                                           // * e2 = -e0 * e1 * Q(e2) = -e0 * e1 *
                                                           //   -1 = e0
                                                           // * e1 = e01
  }

  #[test]
  fn test_mul_trivector() {
    let algebra = clifford_algebra_non_euclidean();
    let e01 = algebra.blade([0, 1]);
    let e2 = algebra.blade([2]);
    let e012 = algebra.blade([0, 1, 2]);

    // Test multiplication with trivector
    assert_eq!(format!("{}", e01.clone() * e2.clone()), "1e₀‚₁‚₂");
    assert_eq!(format!("{}", e2.clone() * e01), "1e₀‚₁‚₂");
    assert_eq!(format!("{}", e012.clone() * e2), "-1e₀‚₁"); // e012 * e2 = e0 * e1 * e2 * e2 = e0 *
                                                            // e1 *
                                                            // Q(e2) = e0 * e1 * -1 = -e0 * e1 =
                                                            // -e01
  }
}
